commit 0602af0ae4687f854da6cbac86e59d6ec2a45d5d
Author: Paul Moore <pmoore2@cisco.com>
Date:   Tue May 18 15:02:28 2021 -0400

    shim: handle single UCS-2 string arguments
    
    Handle the case where we get the second stage loader as a single
    UCS-2 string.
    
    Signed-off-by: Paul Moore <pmoore2@cisco.com>

diff --git a/shim.c b/shim.c
index ebc0da7e..5c0c0d87 100644
--- a/shim.c
+++ b/shim.c
@@ -1545,7 +1545,8 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 		opts = li->LoadOptions;
 
 	/*
-	 * If it's not string data, try it as an EFI_LOAD_OPTION.
+	 * Try to parse the LoadOptions as either a EFI_LOAD_OPTION or as
+	 * a variable number of UCS-2 strings.  Wish us luck.
 	 */
 	if (strings == 0) {
 		/*
@@ -1559,6 +1560,24 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 		if (EFI_ERROR(efi_status))
 			return EFI_SUCCESS;
 
+		remaining_size = 0;
+	} else if (strings == 1) {
+		start = li->LoadOptions;
+		if (is_our_path(li, start)) {
+			/*
+			 * I found a version of BDS that gives us our own path
+			 * in LoadOptions:
+77162C58                           5c 00 45 00 46 00 49 00          |\.E.F.I.|
+77162C60  5c 00 42 00 4f 00 4f 00  54 00 5c 00 42 00 4f 00  |\.B.O.O.T.\.B.O.|
+77162C70  4f 00 54 00 58 00 36 00  34 00 2e 00 45 00 46 00  |O.T.X.6.4...E.F.|
+77162C80  49 00 00 00                                       |I...|
+			 * which is just cruel... So yeah, just don't use it.
+			 */
+			return EFI_SUCCESS;
+		}
+
+		/* assume this string is the second stage loader */
+		loader_len = li->LoadOptionsSize;
 		remaining_size = 0;
 	} else if (strings >= 2) {
 		/*
@@ -1587,19 +1606,9 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 		/* if we didn't find at least one NULL, something is wrong */
 		if (start == li->LoadOptions)
 			return EFI_SUCCESS;
-	} else if (strings == 1 && is_our_path(li, start)) {
-		/*
-		 * And then I found a version of BDS that gives us our own path
-		 * in LoadOptions:
-
-77162C58                           5c 00 45 00 46 00 49 00          |\.E.F.I.|
-77162C60  5c 00 42 00 4f 00 4f 00  54 00 5c 00 42 00 4f 00  |\.B.O.O.T.\.B.O.|
-77162C70  4f 00 54 00 58 00 36 00  34 00 2e 00 45 00 46 00  |O.T.X.6.4...E.F.|
-77162C80  49 00 00 00                                       |I...|
-
-		* which is just cruel... So yeah, just don't use it.
-		*/
-		return EFI_SUCCESS;
+	} else {
+		/* fallback to the default loader */
+		loader_len = 0;
 	}
 
 	/* cleanup if we create a duplicate li->LoadOptions */

commit 066a66ab2f395f13b06947b34609ab0471fcd5ce
Author: Paul Moore <pmoore2@cisco.com>
Date:   Tue May 18 11:55:27 2021 -0400

    shim: fix a regression in set_second_stage()'s LoadOptions parsing
    
    Commit 9e8dde5438ec ("Fix a plausible NULL dereference.") attempted
    to fix a potential NULL pointer dereference but in doing so it
    removed a loop which was necessary to determine the size of the
    second stage loader supplied as an argument to shim.  This breaks
    argument parsing in QEMU+OVMF as well as on various physical systems.
    
    This patch attempts to fix this by determining the length of the
    second stage loader, and any remaining options, while parsing the
    shim command line.
    
    Fixes: 9e8dde5438ec ("Fix a plausible NULL dereference.")
    Signed-off-by: Paul Moore <pmoore2@cisco.com>

diff --git a/shim.c b/shim.c
index c5cfbb83..ebc0da7e 100644
--- a/shim.c
+++ b/shim.c
@@ -1387,10 +1387,12 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 {
 	EFI_STATUS efi_status;
 	EFI_LOADED_IMAGE *li = NULL;
+	void *opts = NULL;
 	CHAR16 *start = NULL;
 	UINTN remaining_size = 0;
 	CHAR16 *loader_str = NULL;
 	UINTN loader_len = 0;
+	CHAR16 *loader_opts = NULL;
 	unsigned int i;
 	UINTN second_stage_len;
 
@@ -1516,22 +1518,31 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 	 * 0016:20 00 6F 00 6E 00 65 00 20 00 74 00 77 00 6F 00 ..o.n.e...t.w.o.
 	 * 0032:20 00 74 00 68 00 72 00 65 00 65 00 00 00       ..t.h.r.e.e...
 	 *
-	 * If so replace it with NULs since the code already handles that
-	 * case.
+	 * If so dup LoadOptions and replace with NULs since the code already
+	 * handles that case.  The LoadOptions buffer is preserved for later
+	 * use (e.g. passing unmunged to the second stage).
 	 */
 	if (strings == 1) {
-		UINT16 *cur = start = li->LoadOptions;
+		UINT16 *cur;
+		UINT16 *cur_dup;
 
-		/* replace L' ' with L'\0' if we find any */
+		/* dup and replace L' ' with L'\0' if we find any */
+		opts = AllocatePool(li->LoadOptionsSize);
+		if (!opts) {
+			perror(L"Failed to duplicate LoadOptions\n");
+			return EFI_OUT_OF_RESOURCES;
+		}
+		cur = li->LoadOptions;
+		cur_dup = opts;
 		for (i = 0; i < li->LoadOptionsSize / 2; i++) {
-			if (cur[i] == L' ')
-				cur[i] = L'\0';
+			cur_dup[i] = (cur[i] == L' ' ? L'\0' : cur[i]);
 		}
 
 		/* redo the string count */
-		strings = count_ucs2_strings(li->LoadOptions,
-					     li->LoadOptionsSize);
-	}
+		strings = count_ucs2_strings(opts, li->LoadOptionsSize);
+	} else
+		/* no changes needed, but set 'opts' so we can use it below */
+		opts = li->LoadOptions;
 
 	/*
 	 * If it's not string data, try it as an EFI_LOAD_OPTION.
@@ -1555,16 +1566,27 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 		 * LoadOptions.  We ignore the string before the first L'\0',
 		 * i.e. the name of this program.
 		 */
-		UINT16 *cur = li->LoadOptions;
-		for (i = 1; i < li->LoadOptionsSize / 2; i++) {
+		UINT16 *cur;
+		UINT16 *cur_orig = li->LoadOptions;
+		cur = opts;
+		start = cur_orig;
+		for (i = 1; i < (li->LoadOptionsSize / 2) - 1; i++) {
 			if (cur[i - 1] == L'\0') {
-				start = &cur[i];
-				remaining_size = li->LoadOptionsSize - (i * 2);
-				break;
+				if (start == li->LoadOptions) {
+					start = &cur_orig[i];
+					loader_len = li->LoadOptionsSize - (i * 2);
+					remaining_size = 0;
+				} else {
+					loader_len = (&cur_orig[i] - start) * 2;
+					loader_opts = &cur_orig[i];
+					remaining_size = li->LoadOptionsSize - (i * 2);
+					break;
+				}
 			}
 		}
-
-		remaining_size -= i * 2 + 2;
+		/* if we didn't find at least one NULL, something is wrong */
+		if (start == li->LoadOptions)
+			return EFI_SUCCESS;
 	} else if (strings == 1 && is_our_path(li, start)) {
 		/*
 		 * And then I found a version of BDS that gives us our own path
@@ -1580,6 +1602,11 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 		return EFI_SUCCESS;
 	}
 
+	/* cleanup if we create a duplicate li->LoadOptions */
+	if (opts != li->LoadOptions)
+		FreePool(opts);
+	opts = NULL;
+
 	/*
 	 * Set up the name of the alternative loader and the LoadOptions for
 	 * the loader
@@ -1596,8 +1623,13 @@ EFI_STATUS set_second_stage (EFI_HANDLE image_handle)
 			loader_str[i] = start[i];
 		loader_str[loader_len/2] = L'\0';
 
+		/*
+		 * Free the default second_stage we allocated at the top of
+		 * this function and use our newly parsed loader_str.
+		 */
+		FreePool(second_stage);
 		second_stage = loader_str;
-		load_options = remaining_size ? start + (loader_len/2) : NULL;
+		load_options = remaining_size ? loader_opts : NULL;
 		load_options_size = remaining_size;
 	}
 

commit c61ff985baf79ebe8efdd7363e75268a0f3ae25b
Author: Seth Forshee <seth.forshee@canonical.com>
Date:   Sat Jun 5 07:34:44 2021 -0500

    Don't unhook ExitBootServices() when EBS protection is disabled
    
    When EBS protection is disabled the code which hooks into EBS is
    complied out, but on unhook it's the code which restores Exit() that
    is disabled. This appears to be a mistake, and it can result in
    writing NULL to EBS in the boot services table.
    
    Fix this by moving the ifdefs to compile out the code to unhook EBS
    instead of the code to unhook Exit(). Also ifdef the definition of
    system_exit_boot_services to safeguard against its accidental use.
    
    Fixes: 4b0a61dc9a95 ("shim: compile time option to bypass the ExitBootServices() check")
    Signed-off-by: Seth Forshee <seth.forshee@canonical.com>

diff --git a/replacements.c b/replacements.c
index 278a8e78..daa2e0f4 100644
--- a/replacements.c
+++ b/replacements.c
@@ -33,7 +33,9 @@ get_active_systab(void)
 static typeof(systab->BootServices->LoadImage) system_load_image;
 static typeof(systab->BootServices->StartImage) system_start_image;
 static typeof(systab->BootServices->Exit) system_exit;
+#if !defined(DISABLE_EBS_PROTECTION)
 static typeof(systab->BootServices->ExitBootServices) system_exit_boot_services;
+#endif /* !defined(DISABLE_EBS_PROTECTION) */
 
 static EFI_HANDLE last_loaded_image;
 
@@ -45,7 +47,9 @@ unhook_system_services(void)
 
 	systab->BootServices->LoadImage = system_load_image;
 	systab->BootServices->StartImage = system_start_image;
+#if !defined(DISABLE_EBS_PROTECTION)
 	systab->BootServices->ExitBootServices = system_exit_boot_services;
+#endif /* !defined(DISABLE_EBS_PROTECTION) */
 	gBS = systab->BootServices;
 }
 
@@ -181,11 +185,8 @@ hook_system_services(EFI_SYSTEM_TABLE *local_systab)
 void
 unhook_exit(void)
 {
-#if !defined(DISABLE_EBS_PROTECTION)
 	systab->BootServices->Exit = system_exit;
 	gBS = systab->BootServices;
-#endif /* defined(DISABLE_EBS_PROTECTION) */
-	return;
 }
 
 void

commit 8fe41600bba666f9c6b4456a97910ace637cfd1a
Author: Jonathan Yong <jonathan.yong@intel.com>
Date:   Fri Apr 16 09:59:03 2021 +0800

    mok: fix potential buffer overrun in import_mok_state
    
    Fix the case where data_size is 0, so config_template is
    not implicitly copied like the size calculation above.
    
    upstream-status: https://github.com/rhboot/shim/issues/249
    
    Signed-off-by: Jonathan Yong <jonathan.yong@intel.com>

diff --git a/mok.c b/mok.c
index beac0ff6..db18093d 100644
--- a/mok.c
+++ b/mok.c
@@ -1034,10 +1034,12 @@ EFI_STATUS import_mok_state(EFI_HANDLE image_handle)
 
 		config_template.data_size = v->data_size;
 
-		CopyMem(p, &config_template, sizeof(config_template));
-		p += sizeof(config_template);
-		CopyMem(p, v->data, v->data_size);
-		p += v->data_size;
+		if (v->data && v->data_size) {
+			CopyMem(p, &config_template, sizeof(config_template));
+			p += sizeof(config_template);
+			CopyMem(p, v->data, v->data_size);
+			p += v->data_size;
+		}
 	}
 	if (p) {
 		ZeroMem(&config_template, sizeof(config_template));

commit f32ec3e58fe4684fe6509cd4b848200954be0a08
Author: Peter Jones <pjones@redhat.com>
Date:   Sat Apr 10 16:05:23 2021 -0400

    Don't call QueryVariableInfo() on EFI 1.10 machines
    
    The EFI 1.10 spec (and presumably earlier revisions as well) didn't have
    RT->QueryVariableInfo(), and on Chris Murphy's MacBookPro8,2 , that
    memory appears to be initialized randomly.
    
    This patch changes it to not call RT->QueryVariableInfo() if the
    EFI_RUNTIME_SERVICES table's major revision is less than two, and
    assumes our maximum variable size is 1024 in that case.
    
    Signed-off-by: Peter Jones <pjones@redhat.com>

diff --git a/mok.c b/mok.c
index 9b8fc2bc..beac0ff6 100644
--- a/mok.c
+++ b/mok.c
@@ -261,6 +261,9 @@ static const uint8_t null_sha256[32] = { 0, };
 
 typedef UINTN SIZE_T;
 
+#define EFI_MAJOR_VERSION(tablep) ((UINT16)((((tablep)->Hdr.Revision) >> 16) & 0xfffful))
+#define EFI_MINOR_VERSION(tablep) ((UINT16)(((tablep)->Hdr.Revision) & 0xfffful))
+
 static EFI_STATUS
 get_max_var_sz(UINT32 attrs, SIZE_T *max_var_szp)
 {
@@ -270,11 +273,21 @@ get_max_var_sz(UINT32 attrs, SIZE_T *max_var_szp)
 	uint64_t max_var_sz = 0;
 
 	*max_var_szp = 0;
-	efi_status = gRT->QueryVariableInfo(attrs, &max_storage_sz,
-					    &remaining_sz, &max_var_sz);
-	if (EFI_ERROR(efi_status)) {
-		perror(L"Could not get variable storage info: %r\n", efi_status);
-		return efi_status;
+	if (EFI_MAJOR_VERSION(gRT) < 2) {
+		dprint(L"EFI %d.%d; no RT->QueryVariableInfo().  Using 1024!\n",
+		       EFI_MAJOR_VERSION(gRT), EFI_MINOR_VERSION(gRT));
+		max_var_sz = remaining_sz = max_storage_sz = 1024;
+		efi_status = EFI_SUCCESS;
+	} else {
+		dprint(L"calling RT->QueryVariableInfo() at 0x%lx\n",
+		       gRT->QueryVariableInfo);
+		efi_status = gRT->QueryVariableInfo(attrs, &max_storage_sz,
+						    &remaining_sz, &max_var_sz);
+		if (EFI_ERROR(efi_status)) {
+			perror(L"Could not get variable storage info: %r\n",
+			       efi_status);
+			return efi_status;
+		}
 	}
 
 	/*

commit bb3ac677301d40b02327de6281167b4497320a08
Author: Gary Lin <glin@suse.com>
Date:   Thu Apr 8 16:23:03 2021 +0800

    mok: allocate MOK config table as BootServicesData
    
    Linux kernel is picky when reserving the memory for x86 and it only
    expects BootServicesData:
    
    https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/arch/x86/platform/efi/quirks.c?h=v5.11#n254
    
    Otherwise, the following error would show during system boot:
    
    Apr 07 12:31:56.743925 localhost kernel: efi: Failed to lookup EFI memory descriptor for 0x000000003dcf8000
    
    Although BootServicesData would be reclaimed after ExitBootService(),
    linux kernel reserves MOK config table when it detects the existence of
    the table, so it's fine to allocate the table as BootServicesData.
    
    Signed-off-by: Gary Lin <glin@suse.com>

diff --git a/mok.c b/mok.c
index 9e37d6ab..9b8fc2bc 100644
--- a/mok.c
+++ b/mok.c
@@ -999,7 +999,7 @@ EFI_STATUS import_mok_state(EFI_HANDLE image_handle)
 		npages = ALIGN_VALUE(config_sz, PAGE_SIZE) >> EFI_PAGE_SHIFT;
 		config_table = NULL;
 		efi_status = gBS->AllocatePages(AllocateAnyPages,
-						EfiRuntimeServicesData,
+						EfiBootServicesData,
 						npages,
 						(EFI_PHYSICAL_ADDRESS *)&config_table);
 		if (EFI_ERROR(efi_status) || !config_table) {

commit 8193bb5ca83a8c2a4a30c5937761e62994220f94
Author: Peter Jones <pjones@redhat.com>
Date:   Wed Mar 31 14:54:52 2021 -0400

    Fix a broken file header on ia32
    
    Commit c6281c6a195edee61185 needs to have included a ". = ALIGN(4096)"
    directive before .reloc, but fails to do so.
    
    As a result, binutils, which does not care about the actual binary
    format's constraints in any way, does not enforce the section alignment,
    and it will not load.
    
    Signed-off-by: Peter Jones <pjones@redhat.com>

diff --git a/elf_ia32_efi.lds b/elf_ia32_efi.lds
index 742e0a47..497a3a15 100644
--- a/elf_ia32_efi.lds
+++ b/elf_ia32_efi.lds
@@ -15,6 +15,7 @@ SECTIONS
    *(.gnu.linkonce.t.*)
    _etext = .;
   }
+  . = ALIGN(4096);
   .reloc :
   {
    *(.reloc)

commit d55ff2166f3252490068713cca7e2d1efeabce38
Author: Adam Williamson <awilliam@redhat.com>
Date:   Thu Apr 8 22:39:02 2021 -0700

    Fix handling of ignore_db and user_insecure_mode
    
    In 65be350308783a8ef537246c8ad0545b4e6ad069, import_mok_state() is split
    up into a function that manages the whole mok state, and one that
    handles the state machine for an individual state variable.
    Unfortunately, the code that initializes the global ignore_db and
    user_insecure_mode was copied from import_mok_state() into the new
    import_one_mok_state() function, and thus re-initializes that state each
    time it processes a MoK state variable, before even assessing if that
    variable is set.  As a result, we never honor either flag, and the
    machine owner cannot disable trusting the system firmware's db/dbx
    databases or disable validation altogether.
    
    This patch removes the extra re-initialization, allowing those variables
    to be set properly.
    
    Signed-off-by: Adam Williamson <awilliam@redhat.com>

diff --git a/mok.c b/mok.c
index 5ad9072b..9e37d6ab 100644
--- a/mok.c
+++ b/mok.c
@@ -888,9 +888,6 @@ EFI_STATUS import_one_mok_state(struct mok_state_variable *v,
 	EFI_STATUS ret = EFI_SUCCESS;
 	EFI_STATUS efi_status;
 
-	user_insecure_mode = 0;
-	ignore_db = 0;
-
 	UINT32 attrs = 0;
 	BOOLEAN delete = FALSE;
 

commit 6f6f5252462a7e24c05a148e895bbe2b7c14d7fd
Author: Peter Jones <pjones@redhat.com>
Date:   Wed Mar 31 09:44:53 2021 -0400

    shim-15.4 branch: update .gitmodules to point at shim-15.4 in gnu-efi
    
    This is purely superficial, as the commit points at the shim-15.4 branch
    already, but some people have found it confusing.
    
    This fixes issue #356.
    
    Signed-off-by: Peter Jones <pjones@redhat.com>

diff --git a/.gitmodules b/.gitmodules
index 2ad8bb84..8fc92a75 100644
--- a/.gitmodules
+++ b/.gitmodules
@@ -1,4 +1,4 @@
 [submodule "gnu-efi"]
 	path = gnu-efi
 	url = https://github.com/rhboot/gnu-efi.git
-	branch = shim-15.3
+	branch = shim-15.4
